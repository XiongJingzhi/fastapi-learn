# 01. 微服务基础 - Microservices Basics

## 📍 在架构中的位置

**从"单体应用"到"微服务架构"**

```
┌─────────────────────────────────────────────────────────────┐
│          单体应用的问题（Monolithic）                         │
└─────────────────────────────────────────────────────────────┘

单个代码库：
    app/
    ├── user/
    ├── order/
    ├── product/
    ├── payment/
    └── notification/

问题：
    - 代码库越来越大，理解困难
    - 部署时间长（一个小改动也要部署整个应用）
    - 扩展不灵活（只能整体扩展，无法单独扩展某个模块）
    - 技术栈锁定（整个应用使用同一技术栈）
    - 故障影响范围大（一个模块的 bug 可能导致整个应用崩溃）
    - 团队协作困难（多个团队修改同一个代码库）

═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│          微服务架构（Microservices）                         │
└─────────────────────────────────────────────────────────────┘

多个独立服务：
    user-service/        (Python/FastAPI)
    order-service/       (Python/FastAPI)
    product-service/     (Go/Gin)
    payment-service/     (Node.js/Express)
    notification-service/ (Python/FastAPI)

好处：
    - 每个服务代码库小，易于理解
    - 独立部署（修改一个服务，只部署该服务）
    - 灵活扩展（高流量服务多部署实例）
    - 技术栈灵活（不同服务可使用不同技术）
    - 故障隔离（一个服务挂了不影响其他服务）
    - 团队自治（小团队负责特定服务）
```

**🎯 你的学习目标**：理解微服务架构的核心概念、优缺点和适用场景。

---

## 🎯 什么是微服务？

### 定义

**微服务架构**是一种将单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，并使用轻量级机制（通常是 HTTP API）进行通信。

### 生活类比：餐厅组织

**单体应用 = 大排档**

```
大排档：
├─ 一个人负责所有工作
├─ 炒菜、煮饭、洗碗、收银都一个人做
├─ 生意好时忙不过来
└─ 这个人生病了？店关门

问题：
- 无法扩展（不能只雇一个炒菜师傅）
- 单点故障（一个人病了就关门）
- 技能单一（只会做某种菜系）
```

**微服务 = 高级餐厅**

```
高级餐厅：
├─ 前厅部：服务员、收银员
├─ 后厨部：主厨、副厨、切菜工
├─ 洗碗部：洗碗工
└─ 采购部：采购员

好处：
- 灵活扩展（生意好时多雇几个服务员）
- 故障隔离（洗碗工请假不影响上菜）
- 专业分工（每个岗位专人负责）
- 团队自治（每个部门独立管理）
```

---

## 📊 微服务 vs 单体应用

### 对比表格

| 特性 | 单体应用 | 微服务架构 |
|------|----------|------------|
| **部署** | 一次性部署所有功能 | 每个服务独立部署 |
| **扩展** | 整体扩展 | 按需扩展特定服务 |
| **技术栈** | 统一技术栈 | 每个服务可独立选择 |
| **故障影响** | 一个模块出错可能影响整体 | 故障隔离，不影响其他服务 |
| **代码库** | 单一大型代码库 | 多个小型代码库 |
| **团队协作** | 多个团队共享代码库 | 每个团队独立负责一个或多个服务 |
| **开发速度** | 初期快，后期慢 | 初期慢，后期快 |
| **运维复杂度** | 简单 | 复杂（需要服务发现、配置中心等） |
| **数据管理** | 共享数据库 | 每个服务独立数据库 |
| **通信** | 函数调用 | 网络通信（HTTP/RPC/消息队列） |
| **测试** | 简单（所有功能在一台机器） | 复杂（需要启动多个服务） |

---

## 🏗️ 微服务的核心特征

### 1. 服务组件化

```
单体应用：
    应用 = 一个进程
    → 所有功能在一个进程内

微服务：
    应用 = 多个服务
    → 每个服务独立进程
    → 服务间通过网络通信
```

### 2. 按业务能力拆分

```
按技术层拆分（错误做法）：
├── controller/     # 控制器层
├── service/        # 服务层
└── repository/     # 数据访问层
    → 一个功能的代码分散在多层

按业务能力拆分（正确做法）：
├── user-service/       # 用户服务
├── order-service/      # 订单服务
├── product-service/    # 产品服务
└── payment-service/    # 支付服务
    → 一个业务的代码集中在一个服务
```

### 3. 去中心化数据管理

```
单体应用：
    一个大数据库
    → 所有服务共享数据库
    → 数据耦合严重

微服务：
    每个服务独立数据库
    → 数据隔离
    → 选择最适合的数据库类型
    （关系型、文档型、键值型等）
```

### 4. 基础设施自动化

```
手动部署：
    人工部署每个服务
    → 容易出错
    → 效率低下

自动化部署：
    CI/CD 自动部署
    → 快速、可靠
    → Docker + Kubernetes
```

### 5. 容错设计

```
没有容错：
    服务 A → 服务 B 挂了 → 服务 A 也挂了 → 级联故障

容错设计：
    服务 A → 服务 B 挂了 → 熔断器打开 → 降级处理 → 服务 A 正常
```

### 6. 演进式设计

```
不要一开始就拆分为微服务
    → 初期开发效率低
    → 增加复杂度

正确做法：
    1. 初期：单体应用
    2. 识别业务边界
    3. 逐步拆分
    4. 演进为微服务架构
```

---

## ✅ 微服务的优势

### 1. 独立部署

```
单体应用：
    修改一行代码
    → 重新编译整个应用
    → 停机部署
    → 风险高

微服务：
    修改一个服务的代码
    → 只重新部署该服务
    → 其他服务不受影响
    → 风险低
```

### 2. 灵活扩展

```
单体应用：
    订单模块流量大
    → 只能整体扩展
    → 资源浪费

微服务：
    订单服务流量大
    → 只扩展订单服务
    → 节省资源
```

### 3. 技术栈灵活

```
单体应用：
    使用 Python
    → 所有模块必须使用 Python

微服务：
    - 用户服务：Python/FastAPI
    - 产品服务：Go/Gin
    - 支付服务：Node.js/Express
    - 搜索服务：Java/Elasticsearch
```

### 4. 故障隔离

```
单体应用：
    通知模块有 bug
    → 内存泄漏
    → 整个应用崩溃

微服务：
    通知服务有 bug
    → 通知服务崩溃
    → 其他服务正常运行
```

### 5. 团队自治

```
单体应用：
    多个团队修改同一代码库
    → 代码冲突频繁
    → 协调成本高

微服务：
    每个团队负责独立服务
    → 代码独立
    → 部署独立
    → 技术选型独立
```

---

## ❌ 微服务的挑战

### 1. 运维复杂度

```
单体应用：
    1 个应用
    → 简单

微服务：
    20+ 个服务
    → 需要服务发现、配置中心、链路追踪、日志聚合等
    → 复杂度指数级增长
```

### 2. 分布式系统的复杂性

```
挑战：
- 网络延迟和故障
- 分布式事务（无法使用 ACID）
- 数据一致性（最终一致性）
- 调试困难（请求跨多个服务）
```

### 3. 服务间通信

```
挑战：
- 通信协议选择（HTTP/gRPC/消息队列）
- 序列化格式（JSON/Protobuf/Avro）
- 服务契约管理
- 版本兼容
```

### 4. 测试复杂度

```
单体应用：
    启动一个应用，测试所有功能

微服务：
    需要启动多个服务
    → 集成测试复杂
    → Mock 服务依赖
```

### 5. 数据一致性

```
单体应用：
    使用 ACID 事务保证一致性

微服务：
    跨服务的数据操作
    → 无法使用 ACID
    → 需要使用 Saga 等模式保证最终一致性
```

---

## 🎯 何时使用微服务？

### 适合使用微服务的场景

```
✅ 大型团队（20+ 人）
✅ 复杂业务（多个业务域）
✅ 需要独立扩展（不同模块流量差异大）
✅ 需要快速迭代（频繁发布新功能）
✅ 多技术栈需求（不同模块适合不同技术）
```

### 不适合使用微服务的场景

```
❌ 小型团队（< 10 人）
❌ 简单业务（单一业务域）
❌ 初创公司（MVP 阶段）
❌ 低流量应用
❌ 团队缺少分布式系统经验
```

---

## 📝 微服务架构示例

### 电商系统拆分

```
原单体应用：
    e-commerce-app/
    ├── user/
    ├── product/
    ├── order/
    ├── payment/
    ├── inventory/
    ├── notification/
    └── analytics/

拆分为微服务：
    user-service/          # 用户管理
    product-service/       # 产品管理
    order-service/         # 订单管理
    payment-service/       # 支付处理
    inventory-service/     # 库存管理
    notification-service/  # 通知服务
    analytics-service/     # 数据分析
    api-gateway/          # API 网关（统一入口）
```

### 服务交互示例

```
用户下单流程：

客户端 → API 网关 → 订单服务
                     ↓
                 ┌───┴───┐
                ↓       ↓
            库存服务  支付服务
                ↓       ↓
            通知服务 ←─┘
```

---

## 🎨 最佳实践

### 1. 从单体开始

```
正确做法：
    1. 初期：单体应用
    2. 业务增长：识别边界
    3. 逐步拆分：先拆变化最频繁的模块
    4. 持续演进：根据业务需求调整

错误做法：
    1. 一开始就设计微服务
    2. 过度拆分
    3. 增加不必要的复杂度
```

### 2. 明确服务边界

```
好的服务边界：
    - 单一职责
    - 高内聚、低耦合
    - 独立的数据存储
    - 清晰的 API 契约

坏的服务边界：
    - 职责不清
    - 高度耦合
    - 共享数据库
    - 频繁的服务间调用
```

### 3. 异步通信优先

```
同步通信（HTTP/gRPC）：
    - 简单直接
    - 强依赖（服务挂了，调用者也失败）
    - 适合：简单查询

异步通信（消息队列）：
    - 解耦
    - 最终一致性
    - 适合：复杂流程、事件通知
```

### 4. 自动化一切

```
自动化：
    - CI/CD（自动测试、构建、部署）
    - 自动扩缩容
    - 自动故障恢复
    - 自动监控告警
```

---

## 🎯 小实验：理解微服务

### 实验 1：运行单体应用

```python
# monolith_app.py
from fastapi import FastAPI

app = FastAPI()

@app.post("/users")
def create_user():
    return {"message": "User created"}

@app.post("/orders")
def create_order():
    return {"message": "Order created"}

@app.post("/products")
def create_product():
    return {"message": "Product created"}

# 运行：uvicorn monolith_app:app --reload
```

### 实验 2：拆分为微服务

```python
# user_service/main.py
from fastapi import FastAPI

app = FastAPI()

@app.post("/users")
def create_user():
    return {"message": "User created"}

# 运行：uvicorn user_service.main:app --port 8001

# order_service/main.py
from fastapi import FastAPI

app = FastAPI()

@app.post("/orders")
def create_order():
    return {"message": "Order created"}

# 运行：uvicorn order_service.main:app --port 8002

# product_service/main.py
from fastapi import FastAPI

app = FastAPI()

@app.post("/products")
def create_product():
    return {"message": "Product created"}

# 运行：uvicorn product_service.main:app --port 8003
```

### 实验 3：使用 Docker Compose 编排

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user_service
    ports:
      - "8001:8000"

  order-service:
    build: ./order_service
    ports:
      - "8002:8000"

  product-service:
    build: ./product_service
    ports:
      - "8003:8000"

  api-gateway:
    build: ./api_gateway
    ports:
      - "8000:8000"
    depends_on:
      - user-service
      - order-service
      - product-service
```

---

## 📚 检查理解

回答这些问题来测试你的理解：

1. **什么是微服务架构？**
   - 提示：将应用拆分为一组小型服务

2. **微服务 vs 单体应用的主要区别？**
   - 提示：部署、扩展、技术栈、故障隔离

3. **微服务的优势和挑战？**
   - 提示：独立部署、灵活扩展 vs 运维复杂、分布式系统复杂性

4. **何时使用微服务？**
   - 提示：大型团队、复杂业务、需要独立扩展

5. **如何从单体应用演进到微服务？**
   - 提示：从单体开始、识别边界、逐步拆分

---

## 🚀 下一步

现在你已经了解了微服务基础，接下来：

1. **学习服务拆分设计**：`notes/02_service_design.md`
2. **学习服务间通信**：`notes/03_service_communication_sync.md`

**记住：微服务不是银弹，不要为了微服务而微服务！合理使用才能发挥其价值！**
